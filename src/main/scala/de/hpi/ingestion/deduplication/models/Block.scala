/*
Copyright 2016-17, Hasso-Plattner-Institut fuer Softwaresystemtechnik GmbH

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package de.hpi.ingestion.deduplication.models

import java.util.UUID
import de.hpi.ingestion.datalake.models.Subject
import de.hpi.ingestion.implicits.CollectionImplicits._

/**
  * Represents the a block resulting from a Blocking Scheme.
  * @param id UUID of the block
  * @param key key generated by a blocking scheme which was used to create this block
  * @param subjects Subjects from the subject table in this block
  * @param staging Subjects from the staging table in this block
  */
case class Block(
    id: UUID = UUID.randomUUID(),
    key: String,
    subjects: List[Subject] = Nil,
    staging: List[Subject] = Nil
) {
    /**
      * Returns the cross product between this blocks subjects and staging subjects.
      * @param f filter function used to exclude Subject tuples from the cross product
      * @return the cross product as List of Subject tuples
      */
    def crossProduct(
        f: (Subject, Subject) => Boolean = (s1: Subject, s2: Subject) => true
    ): List[(Subject, Subject)] = {
        subjects.cross(staging, f).toList
    }

    /**
      * Calculates the number of comparisons resulting from this Block.
      * @return number of comparisons done in this Block
      */
    def numComparisons: Long = subjects.length * staging.length
}

/**
  * Companion object of the Block case class.
  */
object Block {
    /**
      * Splits a block into a number of smaller Blocks by halving the larger column (either subjects or staging).
      * @param block the Block to split
      * @param maxSize maximum number of comparisons allowed for a Block (a value <1 indicates that a Block can be
      *                arbitrarily large)
      * @return List of smaller Blocks containing all comparisons done in the large Block
      */
    def split(block: Block, maxSize: Int): List[Block] = {
        if(maxSize < 1) {
            return List(block)
        }
        var resultBlocks = List(block)
        while(resultBlocks.exists(_.numComparisons > maxSize)) {
            resultBlocks = resultBlocks.flatMap {
                case splitBlock if splitBlock.numComparisons > maxSize =>
                    if(splitBlock.subjects.length >= splitBlock.staging.length) {
                        splitBlock.subjects
                            .halve()
                            .map(subjects => splitBlock.copy(subjects = subjects.toList))
                    } else {
                        splitBlock.staging
                            .halve()
                            .map(staging => splitBlock.copy(staging = staging.toList))
                    }
                case splitBlock => List(splitBlock)
            }
        }
        resultBlocks
    }
}
